;; Select location of potential ignition
;; TO DO = if burning only occurs under 'good' extrinsic conditions then test for fire at all...
to-report ignite-fire
  set fire-size 0
  let succ-ignition? false
  
  let target nobody
  
  ;; Does the fire start in a flammable vegetation type?
  ifelse any? patches with [ class = "d-sh" or class = "m-sh" or class = "gr" ] and random-float 1 <= flamm-start
  [
    set target one-of patches with [ class = "d-sh" or class = "m-sh" or class = "gr" ]
  ]
  [
    set target one-of patches
  ]
  
  ;; Get the fire underway...
  ask one-of patch-set target [ 

    if random-float 1 <= ([flammability] of target * 2)
    [
      ;; record initial fire conditions
      set fire-stats (list (ticks) ([class] of target) (count [neighbors with [flammability < 0.25]] of target ) (mean [flammability] of patches) )

      foreach abundances [ i -> set fire-stats lput (i / world-size) fire-stats ]

      set burned? true
      set pcolor red
      set fire-front patch-set self          ;; A new fire-front patch-set
      set fire-size 1
      set succ-ignition? true                ;; A fire has started!
    ]
  ]

  report succ-ignition?
end

;; THis spreads the fire - idea of a shell follows Ratz (1995)
to fire-spread
  while [ any? fire-front ]                 ;; Stop when we run out of flaming fire-front
  [
    fire-shell
  ]
end

;; Single shell (one round of spread from bruning to non-burning neighbours)
to fire-shell
   let new-fire-front patch-set nobody     ;; Empty set of patches for the next 'round' of the fire

   ask fire-front [

     let candidates neighbors with [ not burned? ]

     ask candidates
     [
       ;; forest cells on edge of open veg are more flammable (as per Tepley et al. in Ecosystems) 
       let edge-wgt count neighbors with [ class = "d-sh" or class = "m-sh" or class = "gr" ] * 0.025

       if random-float 1 <= flammability * (1 + edge-wgt)
       [
         set new-fire-front ( patch-set new-fire-front self)
         set burned? true
       ]
     ]
   ]

   ask new-fire-front [set pcolor red]
   set fire-front new-fire-front
end

;;; fire spread - sped up by using patchset to store the active fire-front
;to fire-spread-fast [extrinsic]
;  
;  set fireSize 1
;  let pSpread 0
;  let fireDamp 1
;  
;  let windSpeed (random 3) + 1
;  let windDirection (random 8) * 45   ;; For convenience this is the direction blowing *towards*
;  
;  ; Modifiers from Millington et al in EMS
;  let windModifiers create-2DArray 3 5 1.0
;  update-2Drow windModifiers 0 array:from-list (list 1.1 1.05 1.0 0.95 0.9)
;  update-2Drow windModifiers 1 array:from-list (list 1.2 1.1 1.0 0.9 0.8)
;  update-2Drow windModifiers 2 array:from-list (list 1.5 1.0 0.9 0.8 0.7)
;  
;  
;  while [ any? fireFront ]                  ;; Stop when we run out of flaming fireFront
;  [  
;     let new-fireFront patch-set nobody     ;; Empty set of patches for the next 'round' of the fire
;   
;     ask fireFront                          ;; Ask patches nieghbouring the fireFront to see if they ignite
;     [
;       
;       let fx pxcor
;       let fy pycor
;       
;       ask neighbors with [ status = 0 ]
;       [
;          
;          let nx pxcor
;          let ny pycor
;          
;          ;; wind calculations   
;          let cellBearing atan (nx - fx)  (ny - fy)       ;; Bearing from ignited pacth (fx,fy) to candidate patch (nx,ny)
;          let relDirn abs(windDirection - cellBearing)    ;; Dir of fire spread relative to wind (difference)
;          if relDirn > 180 [set relDirn 360 - relDirn]  ;; Corrected to bound angle (0,180) 
;          let windWgt get-2Delement windModifiers (windSpeed - 1) (relDirn / 45)
;          
;          ;; edge drying calculations
;          set edgeNhbs n-edge-cells                       ;; Get nhb of edge cells - note this assumes inter-fire drying 
;          let edgeWgt (edgeNhbs * edgeEffect) + 1
;          
;          ;; compute the base flammability multiplier
;          let baseMultiplier (windWgt * (1 + extrinsic) * edgeWgt)
;          
;          
;          set pSpread flammability * baseMultiplier
;          
;          if random-float 1 < (pSpread )
;          [
;            set status 1                                            ;; Need to change status here so they don't get ignited twice
;            set fireSize fireSize + 1
;            set new-fireFront ( patch-set new-fireFront self)       ;; Add newly ignited patches to the new-fireFront
;          ]
;        ]
;     ]
;   
;    ;; ask new-fireFront [set status 1]
;    set fireFront new-fireFront
; 
;   ]    
;   
;   ;; set fireSize count patches with [age = 0]
;   if fireSize > maxFireSize [set maxFireSize fireSize]
;   
;   set fireSizeList lput fireSize fireSizeList
;   set totalBurnedArea totalBurnedArea + fireSize
;   set aveFireSize totalBurnedArea / (length fireSizeList)   
;   
;  ;; reset the burned patches at the end of the fire event; need to update flamm, etc. as
;  ;; there may be multiple fires per year
;  ask patches with [status != 0] 
;  [ 
;    set age 0
;    set status 0
;    set flammability item age flammCurve
;    ;; set flammabilityNhb mean [flammability] of patchNhbs 
;     
;    set fireRecord lput ticks fireRecord 
;    set timesBurned (timesBurned + 1)   
;  ]
; 
; end


to-report getTheta [x1 y1 x2 y2]

  let x_offset x2 - x1
  let y_offset y2 - y1
  
  
  let theta atan x_offset y_offset
  
  ;;if theta > 180 [ set theta theta - ( ( (theta - 180) / 45) * 90) ]

report theta

end

;; this reports the perc-th percentile fire sizes 
;to-report sizePercentileFires [ perc]
;  
;  let s -999
;  
;  if not empty? fireSizeList
;  [
;    set s list-percentile ( sort fireSizeList) perc
;  ]
;  
;  report s
;
;end  

;; reports total burned area of fires of *greater* than the perc-th percentile 
;; e.g. perc = 50 would return the burned area of fires greater than or equal to the median fire size
;to-report areaPercentileFires [perc]
;  
;  let area 0
;  
;  ifelse not empty? fireSizeList
;  [
;    let i 0
;    let critSize list-percentile (sort fireSizeList) perc
;
;    while [i < length fireSizeList]
;    [
;      if item i fireSizeList >= critSize 
;        [ set area area + (item i fireSizeList) ]
;      set i i + 1
;    ]  
;  ]
;  [
;    set area -999
;  ]  
;    
;  report area
;  
;  
;end

;;; reports the slope of a power-law fit to the fire size distribution via MLE
;to-report mle-exponent [size-list xmin]
;  let b -999
;  
;  ;; check that there are sufficient fires (n > 20)
;  if length fireSizeList >= 20 
;  [
;    let mle-est map [(log ? 2) / xmin] size-list
;    set b 1 + ((sum mle-est) ^ -1) 
;  ]
;  
;  report b
;end
;

;; reports the number of fires less than/equal to some size threshold thresh
;; e.g. if thresh = 1, it reports the no. of single cell fires
;to-report nLTEThreshFires [thresh]
;  
;  let i 0
;  let n 0
;    
;  ifelse not empty? FireSizeList
;  [
;
;    while [i < length fireSizeList]
;    [
;      if item i fireSizeList <= thresh [ set n n + 1]
;      set i i + 1
;    ]
;  ]
;  [
;    set n -999
;  ]      
;    
;  report n
;
;end  

;;; burned area over model run
;to-report burnedArea
;
;  let b -999
;  if empty? fireSizeList = false
;   [ set b sum fireSizeList ]
;   
;  report b 
;      
;end
;   
   

